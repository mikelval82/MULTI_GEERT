{
    "EEG_generator.py": "# -*- coding: utf-8 -*-\n\"\"\"\n@author: %(Mikel Val Calvo, Juan Antonio Barios Heredero, Arturo Bertomeu-Motos)\n@email: %(mikel1982mail@gmail.com, juan.barios@gmail.com, arturobm90@gmail.com)\n@institution: %(Dpto. de Inteligencia Artificial, Universidad Nacional de Educación a Distancia (UNED); Center for Biomedical Technology, Universidad Politécnica, Madrid, Spain; Neuroengineering medical group (UMH) )\n@DOI:\n\"\"\"\n\nfrom pylsl import StreamInfo, StreamOutlet\nimport numpy as np\nimport time\nimport sys\nfrom argparse import ArgumentParser\n\n\ndef generate_wave(A, B, f, t, wave_type, phi=0, num_channels=8, noise_level=0.0):\n    \"\"\"Genera una onda cuadrada o sinusoidal con una fase opcional.\"\"\"\n    if wave_type == 'square':\n        # Generar onda cuadrada con fase\n        sample = [A * np.sign(np.sin(2 * np.pi * f * t + phi)) + B + noise_level * np.random.randn() for _ in range(num_channels)]\n    elif wave_type == 'sinusoidal':\n        # Generar onda sinusoidal con fase\n        sample = [A * np.sin(2 * np.pi * f * t + phi) + B + noise_level * np.random.randn() for _ in range(num_channels)]\n    else:\n        raise ValueError(\"Tipo de onda no reconocido. Usa 'square' o 'sinusoidal'.\")\n    return sample\n\n\ndef parse_arguments():\n    \"\"\"Parsea los argumentos de línea de comandos.\"\"\"\n    parser = ArgumentParser(description=\"Generador de señales EEG (ondas 'square' o 'sinusoidal')\")\n    parser.add_argument('wave_type', type=str, choices=['square', 'sinusoidal'], help=\"Tipo de onda: 'square' o 'sinusoidal'\")\n    parser.add_argument('stream_name', type=str, help=\"Nombre del stream para diferenciar los flujos de datos\")\n    parser.add_argument('phi', type=float, help=\"Fase de la onda en radianes\")\n    parser.add_argument('--frequency', '-f', type=float, default=10.0, help=\"Frecuencia de la señal (Hz). Valor por defecto: 10 Hz.\")\n    parser.add_argument('--sampling_rate', '-sr', type=float, default=250.0, help=\"Tasa de muestreo en Hz. Valor por defecto: 250 Hz.\")\n    parser.add_argument('--amplitude', '-A', type=float, default=50.0, help=\"Amplitud de la onda. Valor por defecto: 50\")\n    parser.add_argument('--offset', '-B', type=float, default=0.0, help=\"Desplazamiento de la señal. Valor por defecto: 0\")\n    parser.add_argument('--noise_level', '-n', type=float, default=20.0, help=\"Nivel de ruido (desviación estándar). Valor por defecto: 20\")\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_arguments()\n\n    # Crear la información del stream para la salida LSL\n    info = StreamInfo(args.stream_name, 'EEG', 8, args.sampling_rate, 'float32', 'uid_' + args.stream_name)\n\n    # Añadir metadatos del flujo\n    chns = info.desc().append_child(\"channels\")\n    for label in [\"C3\", \"C4\", \"Cz\", \"FPz\", \"POz\", \"CPz\", \"O1\", \"O2\"]:\n        ch = chns.append_child(\"channel\")\n        ch.append_child_value(\"label\", label)\n        ch.append_child_value(\"unit\", \"microvolts\")\n        ch.append_child_value(\"type\", \"EEG\")\n    info.desc().append_child_value(\"manufacturer\", \"SCCN\")\n    cap = info.desc().append_child(\"cap\")\n    cap.append_child_value(\"name\", \"EasyCap\")\n    cap.append_child_value(\"size\", \"54\")\n    cap.append_child_value(\"labelscheme\", \"10-20\")\n\n    # Crear la salida para el monitor (stream)\n    outlet = StreamOutlet(info)\n\n    # Parámetros para la generación de la onda\n    A = args.amplitude  # Amplitud\n    B = args.offset  # Desplazamiento\n    f = args.frequency  # Frecuencia (Hz)\n    t = 0  # Tiempo inicial\n    dt = 1 / args.sampling_rate  # Paso de tiempo (tasa de muestreo)\n    noise_level = args.noise_level  # Nivel de ruido para añadir variabilidad a la señal\n\n    while True:\n        # Generar la onda (cuadrada o sinusoidal) con la fase proporcionada\n        sample = generate_wave(A, B, f, t, args.wave_type, phi=args.phi, noise_level=noise_level)\n        outlet.push_sample(sample)\n        t += dt  # Incrementar el tiempo\n        time.sleep(dt)  # Sleep por el periodo de muestreo (1/250 segundos)\n\n\nif __name__ == '__main__':\n    main()\n"
}